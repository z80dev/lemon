<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lemon Snake üçã</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #FFFACD 0%, #FFF8DC 50%, #F0E68C 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        h1 {
            color: #8B8000;
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .score-board {
            display: flex;
            gap: 30px;
            margin-bottom: 15px;
            font-size: 1.2rem;
            color: #6B6000;
            font-weight: bold;
        }

        .game-container {
            position: relative;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        canvas {
            display: block;
            background: linear-gradient(145deg, #FFFFE0 0%, #FFFACD 100%);
            border: 4px solid #DAA520;
            border-radius: 12px;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 250, 205, 0.95);
            border-radius: 12px;
            transition: opacity 0.3s ease;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay h2 {
            color: #8B8000;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .overlay p {
            color: #6B6000;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 30px;
            font-size: 1.1rem;
            background: linear-gradient(145deg, #FFD700, #FFA500);
            color: #4A4000;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 165, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 165, 0, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .controls-hint {
            margin-top: 15px;
            color: #8B8000;
            font-size: 0.9rem;
            text-align: center;
        }

        .controls-hint span {
            display: inline-block;
            margin: 0 5px;
        }

        @media (max-width: 500px) {
            h1 {
                font-size: 1.5rem;
            }
            
            .score-board {
                font-size: 1rem;
                gap: 20px;
            }

            canvas {
                border-width: 3px;
            }

            .overlay h2 {
                font-size: 2rem;
            }

            .overlay p {
                font-size: 1rem;
            }

            .btn {
                padding: 10px 25px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <h1>üçã Lemon Snake üçã</h1>
    
    <div class="score-board">
        <span>Score: <span id="score">0</span></span>
        <span>High Score: <span id="highScore">0</span></span>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div id="startOverlay" class="overlay">
            <h2>üçã Lemon Snake üçã</h2>
            <p>Collect lemons to grow!</p>
            <button class="btn" onclick="startGame()">Start Game</button>
        </div>
        
        <div id="gameOverOverlay" class="overlay hidden">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <div class="controls-hint">
        <span>‚¨ÜÔ∏è</span><span>‚¨áÔ∏è</span><span>‚¨ÖÔ∏è</span><span>‚û°Ô∏è</span> Arrow keys or swipe to move
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const finalScoreElement = document.getElementById('finalScore');
        const startOverlay = document.getElementById('startOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');

        // Game settings
        const GRID_SIZE = 20;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const GAME_SPEED = 100; // ms per frame

        // Game state
        let snake = [];
        let direction = { x: 0, y: 0 };
        let nextDirection = { x: 0, y: 0 };
        let lemon = { x: 0, y: 0 };
        let score = 0;
        let highScore = localStorage.getItem('lemonSnakeHighScore') || 0;
        let gameLoop = null;
        let isGameRunning = false;
        let particles = [];

        // Touch handling
        let touchStartX = 0;
        let touchStartY = 0;

        // Initialize
        highScoreElement.textContent = highScore;

        function initGame() {
            // Start snake in center
            const startX = Math.floor(GRID_SIZE / 2);
            const startY = Math.floor(GRID_SIZE / 2);
            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            scoreElement.textContent = score;
            particles = [];
            placeLemon();
        }

        function placeLemon() {
            do {
                lemon.x = Math.floor(Math.random() * GRID_SIZE);
                lemon.y = Math.floor(Math.random() * GRID_SIZE);
            } while (snake.some(segment => segment.x === lemon.x && segment.y === lemon.y));
        }

        function startGame() {
            startOverlay.classList.add('hidden');
            gameOverOverlay.classList.add('hidden');
            initGame();
            isGameRunning = true;
            gameLoop = setInterval(update, GAME_SPEED);
            requestAnimationFrame(render);
        }

        function restartGame() {
            startGame();
        }

        function gameOver() {
            isGameRunning = false;
            clearInterval(gameLoop);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('lemonSnakeHighScore', highScore);
                highScoreElement.textContent = highScore;
            }
            
            finalScoreElement.textContent = score;
            gameOverOverlay.classList.remove('hidden');
        }

        function update() {
            direction = nextDirection;

            // Calculate new head position
            const head = { ...snake[0] };
            head.x += direction.x;
            head.y += direction.y;

            // Check wall collision
            if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                gameOver();
                return;
            }

            // Check self collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            // Move snake
            snake.unshift(head);

            // Check lemon collision
            if (head.x === lemon.x && head.y === lemon.y) {
                score += 10;
                scoreElement.textContent = score;
                createParticles(lemon.x * CELL_SIZE + CELL_SIZE / 2, lemon.y * CELL_SIZE + CELL_SIZE / 2);
                placeLemon();
            } else {
                snake.pop();
            }
        }

        function createParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1,
                    color: `hsl(${45 + Math.random() * 15}, 100%, ${50 + Math.random() * 20}%)`
                });
            }
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#FFFFE0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid pattern
            ctx.strokeStyle = 'rgba(218, 165, 32, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }

            // Draw particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                
                if (p.life > 0) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });

            // Draw lemon
            const lemonX = lemon.x * CELL_SIZE;
            const lemonY = lemon.y * CELL_SIZE;
            const lemonCenterX = lemonX + CELL_SIZE / 2;
            const lemonCenterY = lemonY + CELL_SIZE / 2;

            // Lemon shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(lemonCenterX + 2, lemonCenterY + 4, CELL_SIZE / 2 - 2, CELL_SIZE / 2 - 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lemon body
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(lemonCenterX, lemonCenterY, CELL_SIZE / 2 - 2, CELL_SIZE / 2 - 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lemon highlight
            ctx.fillStyle = '#FFEC8B';
            ctx.beginPath();
            ctx.ellipse(lemonCenterX - 2, lemonCenterY - 2, CELL_SIZE / 4, CELL_SIZE / 6, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Lemon texture dots
            ctx.fillStyle = '#DAA520';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(lemonCenterX + (i - 1) * 3, lemonCenterY + 2, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw snake
            snake.forEach((segment, index) => {
                const segX = segment.x * CELL_SIZE;
                const segY = segment.y * CELL_SIZE;
                const segCenterX = segX + CELL_SIZE / 2;
                const segCenterY = segY + CELL_SIZE / 2;
                const radius = CELL_SIZE / 2 - 1;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.arc(segCenterX + 1, segCenterY + 1, radius, 0, Math.PI * 2);
                ctx.fill();

                // Snake body gradient
                const gradient = ctx.createRadialGradient(
                    segCenterX - 2, segCenterY - 2, 0,
                    segCenterX, segCenterY, radius
                );
                
                if (index === 0) {
                    // Head - brighter green
                    gradient.addColorStop(0, '#90EE90');
                    gradient.addColorStop(1, '#228B22');
                } else {
                    // Body - varying green shades
                    const greenIntensity = Math.max(0.5, 1 - index * 0.05);
                    gradient.addColorStop(0, `hsl(120, 60%, ${60 * greenIntensity}%)`);
                    gradient.addColorStop(1, `hsl(120, 80%, ${30 * greenIntensity}%)`);
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(segCenterX, segCenterY, radius, 0, Math.PI * 2);
                ctx.fill();

                // Snake head details
                if (index === 0) {
                    // Eyes
                    ctx.fillStyle = '#FFF';
                    const eyeOffset = 4;
                    const eyeX = segCenterX + direction.x * 2;
                    const eyeY = segCenterY + direction.y * 2;
                    
                    if (direction.x !== 0) {
                        ctx.beginPath();
                        ctx.arc(eyeX + direction.x * 2, eyeY - eyeOffset, 3, 0, Math.PI * 2);
                        ctx.arc(eyeX + direction.x * 2, eyeY + eyeOffset, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(eyeX - eyeOffset, eyeY + direction.y * 2, 3, 0, Math.PI * 2);
                        ctx.arc(eyeX + eyeOffset, eyeY + direction.y * 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Pupils
                    ctx.fillStyle = '#000';
                    if (direction.x !== 0) {
                        ctx.beginPath();
                        ctx.arc(eyeX + direction.x * 3, eyeY - eyeOffset, 1.5, 0, Math.PI * 2);
                        ctx.arc(eyeX + direction.x * 3, eyeY + eyeOffset, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(eyeX - eyeOffset, eyeY + direction.y * 3, 1.5, 0, Math.PI * 2);
                        ctx.arc(eyeX + eyeOffset, eyeY + direction.y * 3, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Tongue (occasionally flick)
                    if (Math.random() > 0.7) {
                        ctx.strokeStyle = '#FF6347';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(segCenterX + direction.x * radius, segCenterY + direction.y * radius);
                        ctx.lineTo(segCenterX + direction.x * (radius + 6), segCenterY + direction.y * (radius + 6));
                        ctx.stroke();
                    }
                }

                // Segment outline
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(segCenterX, segCenterY, radius, 0, Math.PI * 2);
                ctx.stroke();
            });

            if (isGameRunning) {
                requestAnimationFrame(render);
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!isGameRunning) return;

            switch (e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    e.preventDefault();
                    break;
            }
        });

        // Touch controls
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!isGameRunning) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            const minSwipeDistance = 30;

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > minSwipeDistance) {
                // Horizontal swipe
                if (dx > 0 && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (dx < 0 && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else if (Math.abs(dy) > minSwipeDistance) {
                // Vertical swipe
                if (dy > 0 && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (dy < 0 && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }

            e.preventDefault();
        }, { passive: false });

        // Prevent scrolling on mobile
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Handle visibility change (pause)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isGameRunning) {
                // Optional: pause game
            }
        });

        // Responsive canvas sizing
        function resizeCanvas() {
            const maxSize = Math.min(window.innerWidth - 40, window.innerHeight - 250, 400);
            const scale = maxSize / 400;
            canvas.style.width = `${maxSize}px`;
            canvas.style.height = `${maxSize}px`;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
