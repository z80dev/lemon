defmodule LemonControlPlane.Auth.TokenStore do
  @moduledoc """
  Stores and validates session tokens issued by connect.challenge.

  Tokens are stored with an expiration time and associated identity.
  This provides secure authentication for nodes and devices that have
  completed the challenge flow.

  ## Token Lifecycle

  1. Token is generated by connect.challenge after successful verification
  2. Token is stored with identity info and expiration
  3. Subsequent requests include token in auth.token
  4. Token is validated and identity extracted
  5. Token expires or is revoked

  ## Storage

  Uses LemonCore.Store with :session_tokens namespace.
  """

  alias LemonCore.Store

  @store_namespace :session_tokens

  # Default token TTL: 24 hours
  @default_ttl_ms 24 * 60 * 60 * 1000

  @type token_info :: %{
          token: String.t(),
          identity: map(),
          issued_at_ms: integer(),
          expires_at_ms: integer(),
          conn_id: String.t() | nil
        }

  @doc """
  Store a new session token with associated identity.

  ## Options

  - `:ttl_ms` - Token time-to-live in milliseconds (default: 24 hours)
  - `:conn_id` - Connection ID that issued the token
  """
  @spec store(String.t(), map(), keyword()) :: {:ok, token_info()} | {:error, term()}
  def store(token, identity, opts \\ []) do
    ttl_ms = Keyword.get(opts, :ttl_ms, @default_ttl_ms)
    conn_id = Keyword.get(opts, :conn_id)
    now = System.system_time(:millisecond)

    token_info = %{
      token: token,
      identity: identity,
      issued_at_ms: now,
      expires_at_ms: now + ttl_ms,
      conn_id: conn_id
    }

    Store.put(@store_namespace, token, token_info)
    {:ok, token_info}
  end

  @doc """
  Validate a token and return the associated identity.

  Returns the identity map if valid, or an error if:
  - Token doesn't exist
  - Token has expired
  """
  @spec validate(String.t()) :: {:ok, map()} | {:error, :invalid_token | :expired_token}
  def validate(nil), do: {:error, :invalid_token}
  def validate(""), do: {:error, :invalid_token}

  def validate(token) when is_binary(token) do
    case Store.get(@store_namespace, token) do
      nil ->
        {:error, :invalid_token}

      info when is_map(info) ->
        # Support both atom and string keys (for JSONL reload)
        expires_at = get_field(info, :expires_at_ms)
        identity = get_field(info, :identity)

        cond do
          is_nil(expires_at) or is_nil(identity) ->
            # Malformed token info
            {:error, :invalid_token}

          System.system_time(:millisecond) >= expires_at ->
            # Clean up expired token
            Store.delete(@store_namespace, token)
            {:error, :expired_token}

          true ->
            {:ok, identity}
        end

      # Handle legacy format or malformed data
      _ ->
        {:error, :invalid_token}
    end
  end

  # Safe map access supporting both atom and string keys
  # This handles JSONL reload where keys become strings
  defp get_field(map, key) when is_atom(key) do
    Map.get(map, key) || Map.get(map, Atom.to_string(key))
  end

  @doc """
  Revoke a token, removing it from the store.
  """
  @spec revoke(String.t()) :: :ok
  def revoke(token) when is_binary(token) do
    Store.delete(@store_namespace, token)
    :ok
  end

  def revoke(_), do: :ok

  @doc """
  Get token info without validating expiration.
  Useful for debugging and admin purposes.
  """
  @spec get_info(String.t()) :: token_info() | nil
  def get_info(token) when is_binary(token) do
    Store.get(@store_namespace, token)
  end

  def get_info(_), do: nil

  @doc """
  Clean up all expired tokens.
  Should be called periodically.
  """
  @spec cleanup_expired() :: {:ok, integer()}
  def cleanup_expired do
    now = System.system_time(:millisecond)

    case Store.list(@store_namespace) do
      tokens when is_list(tokens) ->
        # Filter to find expired tokens, supporting both atom and string keys
        expired_tokens =
          tokens
          |> Enum.filter(fn {_token, info} ->
            expires_at = get_field(info, :expires_at_ms)
            expires_at && expires_at < now
          end)

        # Delete expired tokens and count them
        expired_count = length(expired_tokens)

        Enum.each(expired_tokens, fn {token, _info} ->
          Store.delete(@store_namespace, token)
        end)

        {:ok, expired_count}

      _ ->
        {:ok, 0}
    end
  end

  @doc """
  List all active (non-expired) tokens.
  Admin/debug function.
  """
  @spec list_active() :: [token_info()]
  def list_active do
    now = System.system_time(:millisecond)

    case Store.list(@store_namespace) do
      tokens when is_list(tokens) ->
        tokens
        |> Enum.filter(fn {_token, info} ->
          expires_at = get_field(info, :expires_at_ms)
          expires_at && expires_at > now
        end)
        |> Enum.map(fn {_token, info} -> info end)

      _ ->
        []
    end
  end
end
